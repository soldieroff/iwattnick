#include "stm32vl_discovery.h"
#include "gears.h"
#include "stdfun.h"
#include "yagl.h"

// autogenerated by GOC
#include "gfx.h"

static uint8_t catrun [6][20] =
{
    { 32, 160, 86, 118, 63, 60, 28, 28, 28, 28, 30, 14, 14, 12, 30, 26, 26, 25, 25, 1 },
    { 0, 0, 12, 14, 14, 30, 252, 252, 62, 46, 15, 15, 15, 63, 11, 18, 2, 2, 1, 0 },
    { 0, 0, 12, 12, 14, 28, 28, 60, 124, 126, 126, 62, 12, 12, 4, 4, 4, 6, 2, 0 },
    { 0, 0, 6, 7, 7, 62, 126, 28, 60, 188, 252, 248, 48, 32, 48, 16, 24, 16, 0, 0 },
    { 0, 0, 38, 55, 31, 127, 62, 28, 28, 60, 184, 248, 56, 120, 208, 144, 16, 16, 16, 0 },
    { 32, 48, 18, 119, 63, 31, 30, 28, 28, 28, 28, 28, 60, 252, 124, 36, 108, 76, 8, 8 },
};

#define FPS 16

// one-shot-timer that shoots to mark every frame
uint32_t ost_frame;
// frame counter (just increments every frame)
uint8_t frame;
// current display mode
uint8_t dmode;
// scratch variables for display modes
uint8_t x, y, cp, cx;

static void switch_mode (uint8_t mode)
{
    if (mode > 4)
        mode = 0;

    switch (mode)
    {
        case 0:
            memset (g.fb, 0xff, G_FB_SIZE);
            x = y = cp = cx = 0;
            break;

        case 1:
        case 2:
        case 3:
        case 4:
            g_clip_screen ();
            g_clear ();

            if (mode != 1)
            {
                // show the clipping rectangle
                g_color (1);
                g_rect (2, 2, 125, 61);
                g_clip (3, 3, 124, 60);
            }
            break;
    }

    if (dmode == 0)
    {
        y = ST7567_START_LINE (0);
        st7567_send (true, &y, 1);
    }

    dmode = mode;
    frame = 0;
}

static void anim (int x, int y, uint8_t *a)
{
    unsigned nframes = a [1] + 1;
    unsigned delay = a [2] + 1;
    g_anim (x, y, (clock / delay) % nframes, a);
}

int i2s (int n, char *buff, unsigned buffsize, uint8_t g0)
{
    char ch = 11;
    if (n < 0)
    {
        n = -n;
        ch = 10;
    }

    buff [0] = g0 + ch;

    unsigned c = buffsize;
    while (c > 1)
    {
        buff [--c] = g0 + (n % 10);
        n /= 10;
        if (n == 0)
            break;
    }

    memcpy (buff + 1, buff + c, buffsize - c);
    return 1 + buffsize - c;
}

uint32_t g_user_glyph (int x, int y, uint8_t glyph)
{
    char buff [8];
    int n;

    switch (glyph)
    {
        case VAR_speed:
            n = i2s ((clock & 255) - 128, buff, sizeof (buff), BITMAP__0);
            return g_print (x, y, 1, n, buff);

        case VAR_dist:
            n = i2s ((clock >> 4) & 127, buff, sizeof (buff), BITMAP__0);
            return g_print (x, y, 1, n, buff);

        default:
            return 0;
    }
}

static void display ()
{
    frame++;

    switch (dmode)
    {
        case 0:
            for (uint8_t b = 0; b < 8; b++)
                g.fb [b * G_FB_W + x] = rand ();
            x = (x + 1) & 127;
            for (uint8_t b = 0; b < 8; b++)
                g.fb [b * G_FB_W + x] = 255;

            for (uint8_t i = 0; i < 20; i++)
                g.fb [4 * G_FB_W + ((cx + i + 2) & 127)] = catrun [cp][19 - i];
            cx++; cp++; if (cp > 5) cp = 0;

            y = ST7567_START_LINE (y + 1);
            st7567_send (true, &y, 1);
            break;

        case 1:
            g_clear ();
            g_hline (0, 100, 1);
            g_vline (100, 3, 60);
            g_hline (0, 100, 62);
            g_pixel (0, 0);
            g_pixel (100, 0);
            g_pixel (99, 2);
            g_pixel (99, 61);
            g_pixel (0, 63);
            g_pixel (100, 63);
            g_line (3, 3, 97, 60);
            g_line (97, 3, 3, 60);
            g_box (2, 20, 22, 23);
            g_box (2, 30, 22, 53);
            g_bitmap (40, 42, _BITMAP_huge);
            anim (40, 10, _ANIM_catrun);
            anim (70, 30, _ANIM_clearance_forward);
            break;

        case 2:
        {
            g_color ((frame >> 7) ^ 1);

            for (unsigned i = 0; i < 1000; i++)
            {
                int x = rand ();
                int y = ((x >> 16) & 127) - 32;
                x = (x & 255) - 64;
                g_pixel (x, y);
            }
            break;
        }

        case 3:
        {
            g_color ((frame >> 7) ^ 1);

            for (unsigned i = 0; i < 5; i++)
            {
                int x1 = rand ();
                int y1 = ((x1 >> 16) & 127) - 32;
                x1 = (x1 & 255) - 64;

                int x2 = rand ();
                int y2 = ((x2 >> 16) & 127) - 32;
                x2 = (x2 & 255) - 64;

                g_line (x1, y1, x2, y2);
            }
            break;
        }

        case 4:
            g_color (0);
            g_box (0, 0, G_FB_W, G_FB_H);
            g_color (1);
            g_glyph (10, 10, ANIM_cycle_wheel);
            g_glyph (15, 10, BITMAP_cyclist);
            g_glyph (26, 10, ANIM_cycle_wheel);
            g_text (10, 30, TEXT_hello);
            g_text (110, 0, TEXT_vert);
            g_text (10, 40, TEXT_sobaka);
            g_text (20, 50, TEXT_royal);
            g_text (40, 2, TEXT_speed);
            g_text (60, 20, TEXT_dist);
            break;
    }
}

int main (void)
{
    // Отключаем JTAG, оставляем только SWD
    RCC->APB2ENR |= RCC_APB2ENR_AFIOEN;
    AFIO->MAPR |= AFIO_MAPR_SWJ_CFG_JTAGDISABLE;

    // Инициализация стандартной периферии STM32VL-DISCOVERY
    clock_init ();
    led_init ();

    usart1_init ();
    printf ("LCD test started\r\n");

    // Настроим и включим прерывания
    __enable_irq ();

    // Инициализация графической библиотеки
    g_init ();

    ost_disable (&ost_frame);

    switch_mode (0);

    for (;;)
    {
        if (ost_expired (&ost_frame))
        {
            // По нажатию кнопки замораживаем картинку
            if (GPIO (USRBUT)->IDR & BITV (USRBUT))
            {
                while (GPIO (USRBUT)->IDR & BITV (USRBUT))
                    ;
                switch_mode (dmode + 1);
            }

            ost_arm (&ost_frame, CLOCKS (1.0/FPS));
            GPIO (BLED)->ODR ^= BITV (BLED);

            display ();
            g_refresh ();
        }

        // До следующего прерывания нам делать абсолютно нечего
        //__WFI ();
    }
}
