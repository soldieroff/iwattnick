#include "stm32vl_discovery.h"
#include "gears.h"
#include "usefun.h"
#include "yagl.h"
#include "glayout.h"

// autogenerated by GOC
#include "gfx.h"

static uint8_t catrun [6][20] =
{
    { 32, 160, 86, 118, 63, 60, 28, 28, 28, 28, 30, 14, 14, 12, 30, 26, 26, 25, 25, 1 },
    { 0, 0, 12, 14, 14, 30, 252, 252, 62, 46, 15, 15, 15, 63, 11, 18, 2, 2, 1, 0 },
    { 0, 0, 12, 12, 14, 28, 28, 60, 124, 126, 126, 62, 12, 12, 4, 4, 4, 6, 2, 0 },
    { 0, 0, 6, 7, 7, 62, 126, 28, 60, 188, 252, 248, 48, 32, 48, 16, 24, 16, 0, 0 },
    { 0, 0, 38, 55, 31, 127, 62, 28, 28, 60, 184, 248, 56, 120, 208, 144, 16, 16, 16, 0 },
    { 32, 48, 18, 119, 63, 31, 30, 28, 28, 28, 28, 28, 60, 252, 124, 36, 108, 76, 8, 8 },
};

#define FPS 16

// one-shot-timer that shoots to mark every frame
uint32_t ost_frame;
// frame counter (just increments every frame)
uint8_t frame;
// current display mode
uint8_t dmode;
// scratch variables for display modes
int8_t x, y, cp, cx;

static void switch_mode (uint8_t mode)
{
    if (mode > 5)
        mode = 0;

    x = y = cp = cx = 0;
    frame = 0;

    switch (mode)
    {
        case 0:
            memset (g.fb, 0xff, G_FB_SIZE);
            break;

        case 1 ... 5:
            g_clip_screen ();
            g_clear ();

            // show the clipping rectangle
            g_color (1);
            g_rect (2, 2, 125, 61);
            g_clip_set (3, 3, 124, 60);
            break;
    }

    if (dmode == 0)
    {
        y = ST7567_START_LINE (0);
        st7567_send (true, (uint8_t *)&y, 1);
    }

    dmode = mode;
}

int i2s (int n, char *buff, unsigned buffsize)
{
    unsigned x = 0;
    if (n < 0)
    {
        buff [0] = 10;
        n = -n;
        x = 1;
    }

    unsigned c = buffsize;
    while (c > 1)
    {
        buff [--c] = (n % 10);
        n /= 10;
        if (n == 0)
            break;
    }

    memcpy (buff + x, buff + c, buffsize - c);
    return x + buffsize - c;
}

uint32_t g_user_glyph (int x, int y, uint32_t glyph)
{
    char buff [8];
    int n;

    switch (glyph & 0xff)
    {
        case VAR_speed:
            n = i2s ((g_clock & 255) - 128, buff, sizeof (buff));
            return g_printa (x, y, 1, n, buff, glyph >> 8);

        case VAR_dist:
            n = i2s ((g_clock >> 4) & 127, buff, sizeof (buff));
            return g_printa (x, y, 1, n, buff, glyph >> 8);

        default:
            return 0;
    }
}

static void display ()
{
    g_clock = clock;

    switch (dmode)
    {
        case 0:
            for (uint8_t b = 0; b < 8; b++)
                g.fb [b * G_FB_W + x] = rand ();
            x = (x + 1) & 127;
            for (uint8_t b = 0; b < 8; b++)
                g.fb [b * G_FB_W + x] = 255;

            for (uint8_t i = 0; i < 20; i++)
                g.fb [4 * G_FB_W + ((cx + i + 2) & 127)] = catrun [cp][19 - i];
            cx++; cp++; if (cp > 5) cp = 0;

            y = ST7567_START_LINE (y + 1);
            st7567_send (true, (uint8_t *)&y, 1);
            break;

        case 1:
            g_color ((frame >> 7) ^ 1);

            for (unsigned i = 0; i < 1000; i++)
            {
                int x = rand ();
                int y = ((x >> 16) & 127) - 32;
                x = (x & 255) - 64;
                g_pixel (x, y);
            }
            break;

        case 2:
            g_color ((frame >> 7) ^ 1);

            for (unsigned i = 0; i < 5; i++)
            {
                int x1 = rand ();
                int y1 = ((x1 >> 16) & 127) - 32;
                x1 = (x1 & 255) - 64;

                int x2 = rand ();
                int y2 = ((x2 >> 16) & 127) - 32;
                x2 = (x2 & 255) - 64;

                g_line (x1, y1, x2, y2);
            }
            break;

        case 3:
            if (frame == 0)
                cp ^= 1;

            g_color (cp ^ 1);
            g_box (0, 0, G_FB_W - 1, G_FB_H - 1);
            g_color (cp);

            x = sin64 (frame) / 16;
            y = cos64 (frame << 3) / 16;

            for (unsigned i = 0; i < 10; i++)
            {
                g_box (x + 9 + i * 11, y + 1, x + 18 + i * 11, y + 1 + i);
                g_box (x + 9 + i * 11, y + 20, x + 9 + i * 11 + i, y + 29);
                g_box (x + 9 + i * 11, y + 40, x + 9 + i * 11 + i, y + 40 + i);
            }

            break;

        case 4:
            g_color (0);
            g_box (0, 0, G_FB_W - 1, G_FB_H - 1);
            g_color (1);
            g_glyph (10, 30, ANIM_cycle_wheel);
            g_glyph (15, 30, BITMAP_cyclist);
            g_glyph (26, 30, ANIM_cycle_wheel);
            g_text (10, 10, TEXT_hello);
            g_text (10, 40, TEXT_sobaka);
            g_text (20, 50, TEXT_royal);
            g_text (60, 4, TEXT_speed);
            g_text (60, 22, TEXT_dist);
            break;

        case 5:
            if (frame == 0)
                cp ^= 1;

            g_color (cp ^ 1);
            g_box (0, 0, G_FB_W - 1, G_FB_H - 1);
            g_color (cp);

            x = sin64 (frame) / 16;
            y = cos64 (frame << 3) / 16;

            for (unsigned i = 0; i < 10; i++)
                g_bitmap (i * 16 + x, 24 + y, _BITMAP_huge);


            g_text (20 + x, 6 + y, TEXT_royal);
            g_text (10 + x, 16 + y, TEXT_sobaka);
            g_text (10 + x, 40 + y, TEXT_sobaka);
            g_text (20 + x, 50 + y, TEXT_royal);

            break;
    }

    frame++;
}

int main (void)
{
    // Отключаем JTAG, оставляем только SWD
    RCC->APB2ENR |= RCC_APB2ENR_AFIOEN;
    AFIO->MAPR |= AFIO_MAPR_SWJ_CFG_JTAGDISABLE;

    // Инициализация стандартной периферии STM32VL-DISCOVERY
    clock_init ();
    led_init ();

    usart1_init ();
    printf ("LCD test started\r\n");

    // Настроим и включим прерывания
    __enable_irq ();

    // Инициализация графической библиотеки
    g_init ();

    ost_disable (&ost_frame);

    switch_mode (0);

    for (;;)
    {
        if (ost_expired (&ost_frame))
        {
            // По нажатию кнопки замораживаем картинку
            if (GPIO (USRBUT)->IDR & BITV (USRBUT))
            {
                while (GPIO (USRBUT)->IDR & BITV (USRBUT))
                    ;
                switch_mode (dmode + 1);
            }

            ost_arm (&ost_frame, CLOCKS (1.0/FPS));
            GPIO (BLED)->ODR ^= BITV (BLED);

            display ();
            g_refresh ();
        }

        // До следующего прерывания нам делать абсолютно нечего
        //__WFI ();
    }
}
